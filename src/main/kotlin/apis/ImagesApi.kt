/**
* Nekos API
* An open source anime artworks API.
*
* OpenAPI spec version: v3
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package news.apis

import news.models.ArtistSchema
import news.models.ImageSchema
import news.models.PagedCharacterSchema
import news.models.PagedImageSchema
import news.models.PagedTagSchema
import news.models.TagSchema

import dev.icerock.moko.network.NetworkResponse
import io.ktor.client.call.body
import io.ktor.client.HttpClient
import io.ktor.client.request.HttpRequestBuilder
import io.ktor.client.request.request
import io.ktor.client.request.forms.FormDataContent
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.HttpMethod
import io.ktor.http.Parameters
import io.ktor.http.takeFrom
import kotlinx.serialization.json.Json
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.SetSerializer
import kotlinx.serialization.builtins.serializer
import io.ktor.client.call.ReceivePipelineException
import io.ktor.client.request.forms.MultiPartFormDataContent
import io.ktor.client.request.forms.formData
import io.ktor.client.request.forms.submitFormWithBinaryData
import io.ktor.http.ContentDisposition
import io.ktor.http.HttpHeaders
import io.ktor.http.content.TextContent
import io.ktor.http.Headers
import io.ktor.utils.io.core.Input
import io.ktor.http.encodedPath
import io.ktor.http.path

internal interface ImagesApi {

    /**
    * Get an image by ID
    * Returns an image by it&#39;s ID. You&#39;ll get a 404 if the image doesn&#39;t exist. (This endpoint is here below because all the previous ones are resolved first).
    * @param id  
    * @return ImageSchema
    */
    suspend fun nekosapiImagesApiImage(id: kotlin.Int) : ImageSchema

    /**
    * Get an image by ID
    * Returns an image by it&#39;s ID. You&#39;ll get a 404 if the image doesn&#39;t exist. (This endpoint is here below because all the previous ones are resolved first).
    * @param id  
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiImageResponse(id: kotlin.Int) : NetworkResponse<ImageSchema>

    /**
    * Get an image&#39;s artist
    * Returns the artist of the image.
    * @param id  
    * @return ArtistSchema
    */
    suspend fun nekosapiImagesApiImageArtist(id: kotlin.Int) : ArtistSchema

    /**
    * Get an image&#39;s artist
    * Returns the artist of the image.
    * @param id  
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiImageArtistResponse(id: kotlin.Int) : NetworkResponse<ArtistSchema>

    /**
    * Get an image&#39;s characters
    * Returns the characters of the image.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedCharacterSchema
    */
    suspend fun nekosapiImagesApiImageCharacters(id: kotlin.Int, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : PagedCharacterSchema

    /**
    * Get an image&#39;s characters
    * Returns the characters of the image.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiImageCharactersResponse(id: kotlin.Int, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : NetworkResponse<PagedCharacterSchema>

    /**
    * Create an image report
    * Reports an image.
    * @param id  
    * @return void
    */
    suspend fun nekosapiImagesApiImageReport(id: kotlin.Int) : kotlin.Unit

    /**
    * Create an image report
    * Reports an image.
    * @param id  
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiImageReportResponse(id: kotlin.Int) : kotlin.Unit

    /**
    * Get an image&#39;s tags
    * Returns the tags of the image.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedTagSchema
    */
    suspend fun nekosapiImagesApiImageTags(id: kotlin.Int, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : PagedTagSchema

    /**
    * Get an image&#39;s tags
    * Returns the tags of the image.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiImageTagsResponse(id: kotlin.Int, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : NetworkResponse<PagedTagSchema>

    /**
    * Get all images
    * Returns a paginated list of all the verified images in the API.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedImageSchema
    */
    suspend fun nekosapiImagesApiImages(rating: kotlin.collections.List<kotlin.String>? = null, isOriginal: kotlin.Boolean? = null, isScreenshot: kotlin.Boolean? = null, isFlagged: kotlin.Boolean? = null, isAnimated: kotlin.Boolean? = null, artist: kotlin.Int? = null, character: kotlin.collections.List<kotlin.Int>? = null, tag: kotlin.collections.List<kotlin.Int>? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : PagedImageSchema

    /**
    * Get all images
    * Returns a paginated list of all the verified images in the API.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiImagesResponse(rating: kotlin.collections.List<kotlin.String>? = null, isOriginal: kotlin.Boolean? = null, isScreenshot: kotlin.Boolean? = null, isFlagged: kotlin.Boolean? = null, isAnimated: kotlin.Boolean? = null, artist: kotlin.Int? = null, character: kotlin.collections.List<kotlin.Int>? = null, tag: kotlin.collections.List<kotlin.Int>? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : NetworkResponse<PagedImageSchema>

    /**
    * Get a random image file redirect
    * Redirects to a random image file URL.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @return void
    */
    @Deprecated("Coming soon")
    suspend fun nekosapiImagesApiRandomImageFile(rating: kotlin.collections.List<kotlin.String>? = null, isOriginal: kotlin.Boolean? = null, isScreenshot: kotlin.Boolean? = null, isFlagged: kotlin.Boolean? = null, isAnimated: kotlin.Boolean? = null, artist: kotlin.Int? = null, character: kotlin.collections.List<kotlin.Int>? = null, tag: kotlin.collections.List<kotlin.Int>? = null) : kotlin.Unit

    /**
    * Get a random image file redirect
    * Redirects to a random image file URL.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiRandomImageFileResponse(rating: kotlin.collections.List<kotlin.String>? = null, isOriginal: kotlin.Boolean? = null, isScreenshot: kotlin.Boolean? = null, isFlagged: kotlin.Boolean? = null, isAnimated: kotlin.Boolean? = null, artist: kotlin.Int? = null, character: kotlin.collections.List<kotlin.Int>? = null, tag: kotlin.collections.List<kotlin.Int>? = null) : kotlin.Unit

    /**
    * Get random images
    * Returns x random images. It supports all the same filters than the /images endpoint.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @param limit  (optional, default to 100)
    * @return PagedImageSchema
    */
    suspend fun nekosapiImagesApiRandomImages(rating: kotlin.collections.List<kotlin.String>? = null, isOriginal: kotlin.Boolean? = null, isScreenshot: kotlin.Boolean? = null, isFlagged: kotlin.Boolean? = null, isAnimated: kotlin.Boolean? = null, artist: kotlin.Int? = null, character: kotlin.collections.List<kotlin.Int>? = null, tag: kotlin.collections.List<kotlin.Int>? = null, limit: kotlin.Int? = null) : PagedImageSchema

    /**
    * Get random images
    * Returns x random images. It supports all the same filters than the /images endpoint.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @param limit  (optional, default to 100)
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiRandomImagesResponse(rating: kotlin.collections.List<kotlin.String>? = null, isOriginal: kotlin.Boolean? = null, isScreenshot: kotlin.Boolean? = null, isFlagged: kotlin.Boolean? = null, isAnimated: kotlin.Boolean? = null, artist: kotlin.Int? = null, character: kotlin.collections.List<kotlin.Int>? = null, tag: kotlin.collections.List<kotlin.Int>? = null, limit: kotlin.Int? = null) : NetworkResponse<PagedImageSchema>

    /**
    * Get a tag by ID
    * Returns a tag by it&#39;s ID. You&#39;ll get a 404 if the tag doesn&#39;t exist.
    * @param id  
    * @return TagSchema
    */
    suspend fun nekosapiImagesApiTag(id: kotlin.Int) : TagSchema

    /**
    * Get a tag by ID
    * Returns a tag by it&#39;s ID. You&#39;ll get a 404 if the tag doesn&#39;t exist.
    * @param id  
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiTagResponse(id: kotlin.Int) : NetworkResponse<TagSchema>

    /**
    * Get a tag&#39;s images
    * Returns a paginated list of a tag&#39;s images.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedImageSchema
    */
    suspend fun nekosapiImagesApiTagImages(id: kotlin.Int, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : PagedImageSchema

    /**
    * Get a tag&#39;s images
    * Returns a paginated list of a tag&#39;s images.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiTagImagesResponse(id: kotlin.Int, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : NetworkResponse<PagedImageSchema>

    /**
    * Get all tags
    * Returns a list of all tags in the API. You can use this endpoint to create filters in your app.
    * @param search Search for a tag by name or description. (optional)
    * @param isNsfw Whether the tag is NSFW or not. (optional)
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedTagSchema
    */
    suspend fun nekosapiImagesApiTags(search: kotlin.String? = null, isNsfw: kotlin.Boolean? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : PagedTagSchema

    /**
    * Get all tags
    * Returns a list of all tags in the API. You can use this endpoint to create filters in your app.
    * @param search Search for a tag by name or description. (optional)
    * @param isNsfw Whether the tag is NSFW or not. (optional)
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    suspend fun nekosapiImagesApiTagsResponse(search: kotlin.String? = null, isNsfw: kotlin.Boolean? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : NetworkResponse<PagedTagSchema>


    companion object {
        operator fun invoke(basePath: String = "https://api.nekosapi.com", httpClient: HttpClient, json: Json): ImagesApi = ImagesApiImpl(basePath, httpClient, json)
    }
}

internal class ImagesApiImpl(basePath: kotlin.String, httpClient: HttpClient, json: Json): ImagesApi {
    private val _basePath = basePath
    private val _httpClient = httpClient
    private val _json = json

    /**
    * Get an image by ID
    * Returns an image by it&#39;s ID. You&#39;ll get a 404 if the image doesn&#39;t exist. (This endpoint is here below because all the previous ones are resolved first).
    * @param id  
    * @return ImageSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImage(id: kotlin.Int) : ImageSchema {
        try {
            return nekosapiImagesApiImageResponse(id).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get an image by ID
    * Returns an image by it&#39;s ID. You&#39;ll get a 404 if the image doesn&#39;t exist. (This endpoint is here below because all the previous ones are resolved first).
    * @param id  
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImageResponse(id: kotlin.Int) : NetworkResponse<ImageSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/$id")
                return@let startingPath + encodedPath
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = ImageSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

    /**
    * Get an image&#39;s artist
    * Returns the artist of the image.
    * @param id  
    * @return ArtistSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImageArtist(id: kotlin.Int) : ArtistSchema {
        try {
            return nekosapiImagesApiImageArtistResponse(id).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get an image&#39;s artist
    * Returns the artist of the image.
    * @param id  
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImageArtistResponse(id: kotlin.Int) : NetworkResponse<ArtistSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/$id/artist")
                return@let startingPath + encodedPath
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = ArtistSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

    /**
    * Get an image&#39;s characters
    * Returns the characters of the image.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedCharacterSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImageCharacters(id: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : PagedCharacterSchema {
        try {
            return nekosapiImagesApiImageCharactersResponse(id, limit, offset).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get an image&#39;s characters
    * Returns the characters of the image.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImageCharactersResponse(id: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : NetworkResponse<PagedCharacterSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/$id/characters")
                return@let startingPath + encodedPath
            }
            @Suppress("UNNECESSARY_SAFE_CALL")
            with(parameters) {
                limit?.let { append("limit", it.toString()) }
                offset?.let { append("offset", it.toString()) }
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = PagedCharacterSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

    /**
    * Create an image report
    * Reports an image.
    * @param id  
    * @return void
    */
    override suspend fun nekosapiImagesApiImageReport(id: kotlin.Int) : kotlin.Unit {
        try {
            nekosapiImagesApiImageReportResponse(id)
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Create an image report
    * Reports an image.
    * @param id  
    * @return HttpResponse
    */
    override suspend fun nekosapiImagesApiImageReportResponse(id: kotlin.Int) : kotlin.Unit {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Post
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/$id/report")
                return@let startingPath + encodedPath
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

    }

    /**
    * Get an image&#39;s tags
    * Returns the tags of the image.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedTagSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImageTags(id: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : PagedTagSchema {
        try {
            return nekosapiImagesApiImageTagsResponse(id, limit, offset).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get an image&#39;s tags
    * Returns the tags of the image.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImageTagsResponse(id: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : NetworkResponse<PagedTagSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/$id/tags")
                return@let startingPath + encodedPath
            }
            @Suppress("UNNECESSARY_SAFE_CALL")
            with(parameters) {
                limit?.let { append("limit", it.toString()) }
                offset?.let { append("offset", it.toString()) }
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = PagedTagSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

    /**
    * Get all images
    * Returns a paginated list of all the verified images in the API.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedImageSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImages(rating: kotlin.collections.List<kotlin.String>?, isOriginal: kotlin.Boolean?, isScreenshot: kotlin.Boolean?, isFlagged: kotlin.Boolean?, isAnimated: kotlin.Boolean?, artist: kotlin.Int?, character: kotlin.collections.List<kotlin.Int>?, tag: kotlin.collections.List<kotlin.Int>?, limit: kotlin.Int?, offset: kotlin.Int?) : PagedImageSchema {
        try {
            return nekosapiImagesApiImagesResponse(rating, isOriginal, isScreenshot, isFlagged, isAnimated, artist, character, tag, limit, offset).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get all images
    * Returns a paginated list of all the verified images in the API.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiImagesResponse(rating: kotlin.collections.List<kotlin.String>?, isOriginal: kotlin.Boolean?, isScreenshot: kotlin.Boolean?, isFlagged: kotlin.Boolean?, isAnimated: kotlin.Boolean?, artist: kotlin.Int?, character: kotlin.collections.List<kotlin.Int>?, tag: kotlin.collections.List<kotlin.Int>?, limit: kotlin.Int?, offset: kotlin.Int?) : NetworkResponse<PagedImageSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images")
                return@let startingPath + encodedPath
            }
            @Suppress("UNNECESSARY_SAFE_CALL")
            with(parameters) {
                rating?.let { appendAll("rating", it.map { it.toString() }) }
                isOriginal?.let { append("is_original", it.toString()) }
                isScreenshot?.let { append("is_screenshot", it.toString()) }
                isFlagged?.let { append("is_flagged", it.toString()) }
                isAnimated?.let { append("is_animated", it.toString()) }
                artist?.let { append("artist", it.toString()) }
                character?.let { appendAll("character", it.map { it.toString() }) }
                tag?.let { appendAll("tag", it.map { it.toString() }) }
                limit?.let { append("limit", it.toString()) }
                offset?.let { append("offset", it.toString()) }
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = PagedImageSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

    /**
    * Get a random image file redirect
    * Redirects to a random image file URL.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @return void
    */
    override suspend fun nekosapiImagesApiRandomImageFile(rating: kotlin.collections.List<kotlin.String>?, isOriginal: kotlin.Boolean?, isScreenshot: kotlin.Boolean?, isFlagged: kotlin.Boolean?, isAnimated: kotlin.Boolean?, artist: kotlin.Int?, character: kotlin.collections.List<kotlin.Int>?, tag: kotlin.collections.List<kotlin.Int>?) : kotlin.Unit {
        try {
            nekosapiImagesApiRandomImageFileResponse(rating, isOriginal, isScreenshot, isFlagged, isAnimated, artist, character, tag)
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get a random image file redirect
    * Redirects to a random image file URL.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @return HttpResponse
    */
    override suspend fun nekosapiImagesApiRandomImageFileResponse(rating: kotlin.collections.List<kotlin.String>?, isOriginal: kotlin.Boolean?, isScreenshot: kotlin.Boolean?, isFlagged: kotlin.Boolean?, isAnimated: kotlin.Boolean?, artist: kotlin.Int?, character: kotlin.collections.List<kotlin.Int>?, tag: kotlin.collections.List<kotlin.Int>?) : kotlin.Unit {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/random/file")
                return@let startingPath + encodedPath
            }
            @Suppress("UNNECESSARY_SAFE_CALL")
            with(parameters) {
                rating?.let { appendAll("rating", it.map { it.toString() }) }
                isOriginal?.let { append("is_original", it.toString()) }
                isScreenshot?.let { append("is_screenshot", it.toString()) }
                isFlagged?.let { append("is_flagged", it.toString()) }
                isAnimated?.let { append("is_animated", it.toString()) }
                artist?.let { append("artist", it.toString()) }
                character?.let { appendAll("character", it.map { it.toString() }) }
                tag?.let { appendAll("tag", it.map { it.toString() }) }
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

    }

    /**
    * Get random images
    * Returns x random images. It supports all the same filters than the /images endpoint.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @param limit  (optional, default to 100)
    * @return PagedImageSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiRandomImages(rating: kotlin.collections.List<kotlin.String>?, isOriginal: kotlin.Boolean?, isScreenshot: kotlin.Boolean?, isFlagged: kotlin.Boolean?, isAnimated: kotlin.Boolean?, artist: kotlin.Int?, character: kotlin.collections.List<kotlin.Int>?, tag: kotlin.collections.List<kotlin.Int>?, limit: kotlin.Int?) : PagedImageSchema {
        try {
            return nekosapiImagesApiRandomImagesResponse(rating, isOriginal, isScreenshot, isFlagged, isAnimated, artist, character, tag, limit).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get random images
    * Returns x random images. It supports all the same filters than the /images endpoint.
    * @param rating The age rating of the image. (optional)
    * @param isOriginal Whether the image&#39;s idea is original or it uses characters/settings/content from another place (not original). (optional)
    * @param isScreenshot Whether the image is a screenshot of an anime ep./manga page. (optional)
    * @param isFlagged Whether the image is flagged by mods. (optional)
    * @param isAnimated Whether the image is animated or not. This&#39;ll become useful in the future when we add GIFs. (optional)
    * @param artist The artist&#39;s ID. (optional)
    * @param character The character&#39;s ID. (optional)
    * @param tag The tag&#39;s ID. (optional)
    * @param limit  (optional, default to 100)
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiRandomImagesResponse(rating: kotlin.collections.List<kotlin.String>?, isOriginal: kotlin.Boolean?, isScreenshot: kotlin.Boolean?, isFlagged: kotlin.Boolean?, isAnimated: kotlin.Boolean?, artist: kotlin.Int?, character: kotlin.collections.List<kotlin.Int>?, tag: kotlin.collections.List<kotlin.Int>?, limit: kotlin.Int?) : NetworkResponse<PagedImageSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/random")
                return@let startingPath + encodedPath
            }
            @Suppress("UNNECESSARY_SAFE_CALL")
            with(parameters) {
                rating?.let { appendAll("rating", it.map { it.toString() }) }
                isOriginal?.let { append("is_original", it.toString()) }
                isScreenshot?.let { append("is_screenshot", it.toString()) }
                isFlagged?.let { append("is_flagged", it.toString()) }
                isAnimated?.let { append("is_animated", it.toString()) }
                artist?.let { append("artist", it.toString()) }
                character?.let { appendAll("character", it.map { it.toString() }) }
                tag?.let { appendAll("tag", it.map { it.toString() }) }
                limit?.let { append("limit", it.toString()) }
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = PagedImageSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

    /**
    * Get a tag by ID
    * Returns a tag by it&#39;s ID. You&#39;ll get a 404 if the tag doesn&#39;t exist.
    * @param id  
    * @return TagSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiTag(id: kotlin.Int) : TagSchema {
        try {
            return nekosapiImagesApiTagResponse(id).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get a tag by ID
    * Returns a tag by it&#39;s ID. You&#39;ll get a 404 if the tag doesn&#39;t exist.
    * @param id  
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiTagResponse(id: kotlin.Int) : NetworkResponse<TagSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/tags/$id")
                return@let startingPath + encodedPath
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = TagSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

    /**
    * Get a tag&#39;s images
    * Returns a paginated list of a tag&#39;s images.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedImageSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiTagImages(id: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : PagedImageSchema {
        try {
            return nekosapiImagesApiTagImagesResponse(id, limit, offset).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get a tag&#39;s images
    * Returns a paginated list of a tag&#39;s images.
    * @param id  
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiTagImagesResponse(id: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : NetworkResponse<PagedImageSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/tags/$id/images")
                return@let startingPath + encodedPath
            }
            @Suppress("UNNECESSARY_SAFE_CALL")
            with(parameters) {
                limit?.let { append("limit", it.toString()) }
                offset?.let { append("offset", it.toString()) }
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = PagedImageSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

    /**
    * Get all tags
    * Returns a list of all tags in the API. You can use this endpoint to create filters in your app.
    * @param search Search for a tag by name or description. (optional)
    * @param isNsfw Whether the tag is NSFW or not. (optional)
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return PagedTagSchema
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiTags(search: kotlin.String?, isNsfw: kotlin.Boolean?, limit: kotlin.Int?, offset: kotlin.Int?) : PagedTagSchema {
        try {
            return nekosapiImagesApiTagsResponse(search, isNsfw, limit, offset).body()
        } catch (pipeline: ReceivePipelineException) {
            throw pipeline.cause
        }
    }

    /**
    * Get all tags
    * Returns a list of all tags in the API. You can use this endpoint to create filters in your app.
    * @param search Search for a tag by name or description. (optional)
    * @param isNsfw Whether the tag is NSFW or not. (optional)
    * @param limit  (optional, default to 100)
    * @param offset  (optional, default to 0)
    * @return HttpResponse
    */
    @Suppress("UNCHECKED_CAST")
    override suspend fun nekosapiImagesApiTagsResponse(search: kotlin.String?, isNsfw: kotlin.Boolean?, limit: kotlin.Int?, offset: kotlin.Int?) : NetworkResponse<PagedTagSchema> {
        val builder = HttpRequestBuilder()

        builder.method = HttpMethod.Get
        builder.url {
            takeFrom(_basePath)
            encodedPath = encodedPath.let { startingPath ->
                path("v3/images/tags")
                return@let startingPath + encodedPath
            }
            @Suppress("UNNECESSARY_SAFE_CALL")
            with(parameters) {
                search?.let { append("search", it.toString()) }
                isNsfw?.let { append("is_nsfw", it.toString()) }
                limit?.let { append("limit", it.toString()) }
                offset?.let { append("offset", it.toString()) }
            }
        }

        with(builder.headers) {
            append("Accept", "application/json")
        }

        val response = _httpClient.request(builder)

        val serializer = PagedTagSchema.serializer()

        return NetworkResponse(
            httpResponse = response,
            bodyReader = { _json.decodeFromString(serializer, it.body()) }
        )
    }

}
